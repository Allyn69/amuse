
Development log for the smallN MUSE package
-------------------------------------------

--> Still instructive, despite the numerous wrong turns!


1. Created C++ package

	- integrator, analysis, drivers, Makefile

	- interface code (drivers <--> integrator/analysis)
	  is in muse_interface.cc, header = muse_interface.h

	- uses Starlab -- header files and libraries

2. Want to interface this with MUSE.

	- initially created muse_interface.i:

		%module muse_interface

		%{
		#include "muse_interface.h"
		%}

		%include "muse_interface.h"

   Running make compile creates

	muse_interface.py

		- created by swig
		- name follows the %module name in muse_interface.i
		- internally imports _muse_interface, name also derived
		  from the %module line

	_muse_interface_interface.so

		- created by the make process
		- name created by swig.make; derives from the name
		  muse_interface.i by tacking an extra _interface
		  onto it

	--> the current naming schemes are a potentially serious source
	--> of inconsistency, TO BE FIXED, but for now, just rename:

		%module muse_interface_interface

		%{
		#include "muse_interface.h"
		%}

		%include "muse_interface.h"

   Now running clean compile creates

	muse_interface_interface.py

		- internally imports _muse_interface_interface

	_muse_interface_interface.so


   Import this into muse_multiple.py by

	import muse_interface_interface as MI

   Then use muse_multiple to define SmallN in python

	from muse_multiple import SmallN

3. Problem: when we do this import, we get

	ImportError:
  /home/steve/muse/branches/steve/multiples/smallN/_muse_interface_interface.so:
	undefined symbol: _Z9randinterdd

   Reason: this is one of the (many) Starlab library functions
   referenced in muse_interface.  To fix, we have to import the
   Starlab libraries.

   To do this

   (i) Convert the static Starlab libraries into a single shared
   libary by (make_shared):

	#!/bin/sh -f

	cd $STARLAB_INSTALL_PATH/lib/starlab

	lib=starlab
	ld -s -shared -h $PWD/lib$lib.so -o lib$lib.so -whole-archive \
		libdstar.a \
		lib_dyn_.a \
		libdyn.a \
		libhdyn.a \
		libhydro.a \
		libnode.a \
		libsstar.a \
		libstd.a \
		libstubs.a \
		libtdyn.a \
		libxhdyn.a

	--> how to import a specified shared library into python?
	--> just copy it to the local directory for now, and say

		import libstarlab

	--> but now we get a new message

		ImportError: ./libstarlab.so: undefined symbol:
		_ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc

	--> ??? not clear that this is going to converge...

   (ii) Instead, try including the static Starlab libraries in
	_muse_interface_interface.so by listing them in the LIBS
	variable.  Now importing _muse_interface_interface leads to
	the error

		ImportError:
  /home/steve/muse/branches/steve/multiples/smallN/_muse_interface_interface.so:
		undefined symbol: _Z12my_sys_statsP3dyn

	nm reveals that the symbol is contained in the library, but is
	undefined -- because it lives analyze.cc!

	Add analyze.o and integrate.o to OBJS, and now the error is

	    ImportError:
  /home/steve/muse/branches/steve/multiples/smallN/_muse_interface_interface.so:
	    undefined symbol: _ZN4hdyn11merge_nodesEPS_i

	and nm reveals that _ZN4hdyn11merge_nodesEPS_imerge_Nodes is
	indeed undefined, but why?

	It exists in libhdyn.a and is also referenced in function
	dstar_to_kira, in libdstar.a.  Is this the usual problem
	involving the order in which libraries are referenced?
	Duplicate libhdyn in Makefile and recompile.

	    from multiples.multiples import Multiples
	    ImportError: No module named multiples.multiples

	We seem to have fixed the muse_interface_interface problem,
	but the import path is apparently not correct.  Why??

	--> looks like we MUST have the __init__.py file!!

4. Now test.py silently does nothing!  Good!!
   Replicated muse_driver -- WORKS!!

   TODO/cleanup:

	- reconsider the _interface naming scheme

	- reconsider the module naming scheme -- multiples or multiple?

	- clean up the interface functions setting/getting positions
	  and velocities -- specifically, we need (as usual), a class
	  combining mass, position, and velocity, for easy transfer in
	  and out

		--> should this class be global to MUSE?
