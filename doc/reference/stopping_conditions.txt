====================
Stopping Conditions
====================

Introduction
------------
Codes in AMUSE evolve their models in three loops, the "inner", 
the "outer" loop, and the "script" loop. The 
"inner" loop is controlled by the code and evolves the model 
in a sufficiently small step to limit errors
and be able to simulate important physics. The "outer" loop invocates
the "inner" loop until a condition is met specified by the AMUSE script.
The AMUSE script (or the "script" loops) interacts with the "outer"
loop.

 .. graphviz::
    
    digraph layers0 {
      fontsize=10.0;
      node [fontsize=10.0,shape=box, style=filled, fillcolor=lightyellow, width=1.5];
      subgraph cluster0 {
      fontsize=10.0;
            style=filled;
            color=azure2;
            labeljust="l";
            label="AMUSE Script";
            "script loop";
      } 
      subgraph cluster1 {
      fontsize=10.0;
            style=filled;
            color=azure2;
            labeljust="l";
            label="Legacy Code";
            "outer loop";
            "inner loop";
      }
      "script loop" -> "outer loop"[minlen=2];
      "outer loop" -> "inner loop";
      
      "script loop" -> "script loop"  [dir="back", constraint=false,minlen=2, headport="se", tailport="ne"];
      "outer loop" -> "outer loop"[dir="back", constraint=false, headport="se", tailport="ne"];
      "inner loop" -> "inner loop"[dir="back", constraint=false, headport="se", tailport="ne"];
    }

In AMUSE the outerloop is always limited by the model time. Every 
:func:`evolve` call has one argument, the model time. When the
simulation goes beyond this time, control is returned to the caller.
This process is shown in the following code example.

.. code-block:: c

    // example outer loop
    void outer_loop(double end_time) 
    {
        while(model_time < end_time) 
        {
            ...
            inner_loop()
            ...
            model_time += delta_time_for_this_step
        }
        return
    }

The model time is often enough to control the loop, but some
situations call for an earlier break in the loop when the model 
time has not reached the end time. The framework supports
**stopping conditions** to be able to break the outer loop
before the end time is hit. The following code example,
shows how these conditions might work.

.. code-block:: c

    // example outer loop with stopping conditions
    void outer_loop(double end_time) 
    {
        int special_condition_was_hit = 0;
        
        while(model_time < end_time) 
        {
            ...
            inner_loop()
            ...
            check_if_special_conditions_are_hit();
            ...
            model_time += delta_time_for_this_step
            ...
            if(special_condition_was_hit) {
                break;
            }
        }
        return
    }

For example, a code might be able to detect a collision 
of two stars and the user wants to handle this event. 
If the code would proceed to the end time, the collision 
is long over and the user has no way to know about
the collision and cannot handle it.

.. image:: stopping_conditions_collision.png

AMUSE provides a framework for using and implementing stopping
conditions. This framework uses simple tables in the
codes and translates these tables to objects in the python 
scripts. In the next section the use of this framework 
is described. In the final section the implementation of
the framework in a legacy code is described.

Using stopping conditions
-------------------------

All ineraction with the *stopping conditions* of a *legacy code*
is via the :attr:`stopping_conditions` attribute of a :class:`CodeInterface`
class. When the :attr:`stopping_conditions` attribute is 
queried it returns a :class:`StoppingConditions` object. All 
:class:`StoppingConditions` objects have an attribute for each
stopping condition supported by AMUSE. The 
attributes have the following names:
    
collision_detection
    The outer loop breaks when two stars connect
pair_detection
    The outer loop breaks when two stars pair, possibly
    creating a binary star.
escaper_detection
    The outer loops breaks when a star escapes the
    simulation (is no longer gravitationally bound
    to the other stars)
timeout_detection
    The outer loops breaks when a certain amount
    of computer (wall-clock) has elapsed.

.. note ::

    :class:`CodeInterface` objects provide a object oriented
    interface to the legacy codes.
    

All :class:`StoppingConditions` objects provide a string 
representation describing the supported conditions and their
states.

.. code-block:: python

    >>> from amuse.lab import *
    >>> code = Hermite()
    >>> print code.stopping_conditions
    Stopping conditions of a 'Hermite' object
    * supported conditions: collision_detection, pair_detection, timeout_detection
    * enabled conditions: none
    * set conditions: none
    >>> code.stop()

For every attribute the user can determine if it is
supported, if it was enabled or if it was hit during
the :func:`evolve` loop.

.. code-block:: python

    >>> from amuse.lab import *
    >>> code = Hermite()
    >>> print code.stopping_conditions.collision_detection.is_supported()
    True
    >>> print code.stopping_conditions.collision_detection.is_enabled()
    False
    >>> print code.stopping_conditions.collision_detection.is_set()
    False
    >>> code.stop()

When a stopping condition was hit the user can query which particles 
were involved in the condition. The particles involved are stored in
columns. For pair wise detections (collection and pair) the condition
provides two columns. The first column contains all the first particles
of the pairs and the second column contains all the second particles
of the pairs. These columns can be queried with the :meth:`particles`
method on a stopping condition attribute. This method takes one 
argument, the columnindex.

========  ============  ============
Pair      particles(0)  particles(1)
========  ============  ============
1 + 2     1              2
5 + 11    5              11
12 + 10   12             10
========  ============  ============

.. code-block:: python

    >>> from amuse.lab import *
    >>> code = Hermite()
    >>> sc = code.stopping_conditions.collision_detection
    >>> sc.enable()
    >>> code.evolve_model(0.1 | nbody_system.time)
    >>> print sc.is_set()
    True
    >>> print sc.particles(0)
    ...
    >>> pair = sc.particles(0)[0], sc.particles(1)[0] 
    >>> code.stop()

Implementing stopping conditions
--------------------------------
All codes supporting stopping conditions
must implement the :class:`StoppingConditionInterface`
interface. This can be easily done by inheriting
from the :class:`StoppingConditionInterface` and implementing
all the functions defined in the interface.

.. code-block:: python

    class MyCodeInterface(LegacyInterface, StoppingConditionInterface):
        ...
        
This :class:`StoppingConditionInterface` interface models the interface to a
simple data model, best described as two tables::

Defined stopping conditions table
    This table list the types of stopping conditions
    and if these are supported by the code, and if so, if 
    these are enabled by the user.
    
    ======  ========= ========
    type    supported enabled 
    int     int       int
            read only read/write
    ======  ========= ========  
    0       0         0
    1       1         0
    2       0         0
    3       1         0
    ======  ========= ========  

    type
        The type of the stopping condition, integer between
        0 and N. defined by the framework
    supported
        1 if the stopping condition is supported, 0 otherwhise.
        Needs to be set by the implementor
    enabled
        1 if enabled by the user, 0 otherwhise.
        Implementor must provide a mechanism to set and unset 
        this field.

Set stopping conditions table
    This table has a row for each stopping condition
    set during the outer and inner loop evaluations.
    Every row lists the type of condition set and which
    particles were involved (if any). The id of the
    last particle in the list must be -1.
    
    ======  =========== =========== ======= ============
    type    particle[0] particle(1) ...     particle(n)
    int     int         int         int     int
    ======  =========== =========== ======= ============
    1       1           2           -1      -1
    1       10          12          -1      -1
    3       -1          ...
    1       11          20          ...    
    ...
    3       -1
    ======  =========== =========== ======= ============

    type
        The type of the stopping condition, integer between
        0 and N. defined by the framework. Set by the code
    particle(0...n)
        Index of the particle involved in the stopping condition.
        The index of the last particle must be -1

.. autoclass:: amuse.legacy.support.stopping_conditions.StoppingConditionInterface
    :members:

This interface contains a lot of functions and implementing it 
might be a time consuming task. To help implementing the 
interface, AMUSE provides a C library that does most of the 
table management, this library is described in the next section.

Using the stopping conditions library
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
The stopping conditions tables are implemented as a 
static C library. This library is part of the AMUSE distribution
and can be found in the ```lib/stopcond``` directory. 







