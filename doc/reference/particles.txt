==========================
Datamodel
==========================


Introduction
------------

The AMUSE datamodel is based on objects stored in containers. The 
containers store all the relevant data of the objects. One can work 
with the data in a container as a whole or with an indiviual object 
in a container. When working with an individual object all data will 
be retrieved from and stored in the container of that object. *This 
is different from normal python objects and lists where the lists 
store references to the objects and the data is stored on the 
objects*.

AMUSE supports two kinds of containers. One container kind 
implements a one dimensional set of objects. You can add and remove 
objects from the set and combine sets in different ways. This 
container kind is called **'Particles'** and the individual objects 
stored are called **'Particle'**. The other container kind 
implements a multidimensional grid of objects. You cannot change the 
shape of a grid and objects cannot be added or removed from a 
grid. This container kind is called **'Grid'** and individual 
objects stored in the container are called **'GridPoint'**.  

The containers in AMUSE can save the data for individual objects in 
different kinds of **'Stores'**. AMUSE currently implements 3 kinds 
of stores. One kind of store saves all data in memory, this kind is 
used by default and provides the fastest way to work with the 
containers. Another kind of store saves and retrieves all data from 
a community code. It uses MPI messages to communicate this data. 
This kind is used by default for containers provided by a code and 
is the primary way by which you can interact with the data inside a 
running code. The last kind of container stores and retrieves data from
an HDF5 file. This kind is only used when saving or loading a container.

In memory containers can support a user defined set of attributes 
for the contained objects. You can define a new attribute for the 
container by assigning a value to the attribute. In code containers 
support a pre-defined, per code set of attributes for the contained 
objects. You cannot define a new attribute on these containers. Also 
as a code may not allow some attributes to be set individually, the 
container also cannot set some attributes individually. For example 
you often cannot set the X position of a particle, you must set the 
X, Y, and Z position in one go.

Different kinds of particles or gridpoints are not modelled by 
implementing subclasses. Instead, different kinds of particles are 
defined ad-hoc, by variable naming (for example planets, stars or 
cloud_particles) and varying attributes (stars have position and 
mass, cloud_particles have position and density). This allows you to 
model your problem with the names and attributes that best fit your 
model. Unfortunately, this way of working does remove a level of 
self description in the system. To mitigate this problem the 
containers defined in community codes and in example scripts all 
follow the same conventions. We describe these conventions in a 
later section in this chapter.

Identity
--------
All particles have a unique 64-bit key. This key is generator
using a random number generator. The chances of duplicate keys
using 64-bit integers are finite but very low.This chance of a duplicate
key can be determined by a generalization of the birthday problem.

Duplicate keys::
    >>> # given n random integers drawn from a discrete uniform distribution 
    >>> # with range [1,highest_integer], what is the probability
    >>> # p(n;highest_integer) that at least two numbers are the same?
    >>> import math
    >>> number_of_bits = 64
    >>> highest_integer = 2**number_of_bits
    >>> number_of_particles = 1000000.0 # one million
    >>> probability = 1.0 - math.exp( (-number_of_particles * (number_of_particles - 1.0))/ (2.0* highest_integer) )
    >>> print probability
    2.71050268896e-08
    >>> # can also set the probablity and determine the set size
    >>> probability = 0.00001 # 0.001 percent
    >>> number_of_particles = math.sqrt(2 * highest_integer * math.log(1 / (1.0 - probability)))
    >>> print number_of_particles
    19207725.6894
    
If you use large sets or want to load a lot of simulations with different
particles into a script the probablity of encountering a duplicate
may be too high. An extension to more larger key sizes is planned but
not yet implemented. You can check for duplicates in a set of particles
by calling ``has_duplicates`` on a set.
    

Sets of particles
------------------
The AMUSE datamodel assumes all particles come in sets. The
data of a particle is stored in the set.

.. automodule:: amuse.datamodel

    .. autoclass:: AbstractParticleSet
        :members:
        
        .. automethod:: __add__
        .. automethod:: __sub__
        
    .. autoclass:: Particles
        :members:
        
    .. autoclass:: ParticlesSubset
        :members:
        
    .. autoclass:: ParticlesWithUnitsConverted
        :members:

    object
    ---------------

    .. autoclass:: Particle
        :members:
        
        .. automethod:: __add__
        .. automethod:: __sub__
    
    Methods to retreive physical properties of the particles set
    ------------------------------------------------------------
    
.. automodule:: amuse.datamodel.particle_attributes

    .. autofunction:: center_of_mass 
        :noindex:
    .. autofunction:: center_of_mass_velocity
        :noindex:
    .. autofunction:: kinetic_energy
        :noindex:
    .. autofunction:: potential_energy 
        :noindex:
    .. autofunction:: particle_specific_kinetic_energy
        :noindex:
    .. autofunction:: particle_potential
        :noindex:

    


