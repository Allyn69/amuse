============
Architecture
============

Layers
------
The AMUSE architecture is based on a layered design with 3 layers. 
The highest layer is a python script, written for a single problem
or set of problems. The next layer contains the AMUSE code, this layer
provides a library of objects and function to use in the python script. 
The last layer contains all the existing codes. In this layer the 
physical models are implemented.

Each layer builds upon a lower layer, adding functionality or ease of
use to the previous layer:

.. raw:: latex

   \begin{figure}[htp] \centering
   
.. graphviz::
    
    digraph layers0 {
      node [shape=box, style=filled, fillcolor=lightyellow, width=3];
      subgraph cluster0 {
            style=filled;
            color=azure2;
            labeljust="l";
            label="Layer 1";
            level1 [label = "User Script"];
      } 
      subgraph cluster1 {
            style=filled;
            color=azure2;
            labeljust="l";
            label="Layer 2";
            level2 [label = "AMUSE Code"];
      }
    
      subgraph cluster2 {
            style=filled;
            color=azure2;
            labeljust="l";
            label="Layer 3";
            level3 [label = "Legacy Codes"];
      }
      level1 -> level2 -> level3
    }

.. raw:: latex

   \caption{The 3 layers in AMUSE}
   \end{figure} 

Each layer has a different role in the AMUSE architecture:

1. **User Script layer**. The code in this layer implements a specific 
   physical problem or sets of problems. This layer contains the 
   example scripts and scripts written by the user. This layer is 
   conceptually comparable to a User Interface layer.

2. **AMUSE Code layer**. This layer provides an object oriented 
   interface on top of the legacy codes and provides a library
   of functionalities, such as unit handling and data conversion.
   This role of this layer is very generic, it is not specific 
   for one problem or for one physical domain.
   
3. **Legacy Codes layer**.  This layer interfaces to the legacy codes 
   and contains the existing codes. It provides process management
   for the legacy codes and functional interfaces to the codes. 
   The code in this layer is generic in respect to problems, but 
   speficic for different physical domains.

The following sections contain a detailed explaination of the layers
starting with the lowest layer to the highest. Some details are further
worked out in other chapters or in the reference manual.

Legacy codes layer
******************

The **Legacy Codes layer** contains the existing applications and 
the functionality to interface with these applications. This
layer exposes every legacy code as a set of functions. These 
functions are grouped in one class per code. 

The AMUSE framework code and the legacy codes are designed to be run 
as separate applications. Function calls into the legacy codes 
will be send via a *message passing framework* to the codes.

.. raw:: latex

   \begin{figure}[htp] \centering

.. graphviz::

   digraph layers4 {
        rankdir="LR";
        node [shape=box, style=filled, fillcolor=lightyellow];
        subgraph cluster0 {
            style=filled;
            color=azure2;
            label="Application";
            
            "Python Interfaces";
        }
        "Message Passing Framework";
        subgraph cluster1 {
            style=filled;
            color=azure2;
            label="Application";
            "Legacy Code";
        }
        "Python Interfaces" -> "Message Passing Framework";
        "Legacy Code" -> "Message Passing Framework";
        
        "Message Passing Framework" -> "Legacy Code";
        "Message Passing Framework" -> "Python Interfaces";
    }

.. raw:: latex

   \caption{Legacy codes are categorized in different domains}
   \end{figure} 

The amuse framework interacts with legacy codes via a message passing
framework. Function calls in the python scripts are translated
to messages and these messages are send to the legacy codes 
using the message passing framework . The legacy codes wait 
for message events and will decode the message upon arrival and 
perform the requested function. The results will be send back 
using a similar message.


.. image:: message_passing.png


AMUSE Code layer
****************

The **AMUSE Code layer** is responsible for providing an object
oriented interface to the legacy codes. It also provides extra 
functionality to help write a user script, such as file input 
and output of common file formats and unit conversions. These
extra functionalities can be used indepented of the legacy codes.


.. graphviz::

    digraph amcode_0{
        compound=true;
        ranksep=1;
        
        node [shape=box, style=filled, fillcolor=lightyellow];
        subgraph cluster0 {
            style=filled;
            color=azure2;
            label="Object Oriented Interface";
            "Unit Conversion";
            "Code Interface";
            "State";
            "Exceptions";
        }
        
        subgraph cluster1 {
            style=filled;
            color=azure2;
            label="Data Model";
            "Particles" ;
            "Grid Points";
        }
        "Legacy Interface";
        "Code Interface" -> "Legacy Interface"[ ltail=cluster0];
        subgraph cluster2 {
            style=filled;
            color=azure2;
            label="Support";
            
            "Input/Ouput";
            "Units";
        }
        
        "Code Interface" -> "Particles"[lhead=cluster1, ltail=cluster0]; 
        "Code Interface" -> "Units"[lhead=cluster2, ltail=cluster0]; 
    }

The **AMUSE code layer** classes build upon the low level
classes provided by the **legacy codes layer**. The design is based
on adaptor and decorator patterns to provide interfaces with increasing
functionality. First a  *Legacy interface* class is adapted to create a
class which provides *"parameters"*, *"particle sets/gridpoints"* and 
*"methods with units"*. Next, more functionality is added to objects of 
this class by defining decorators. 

.. graphviz::

    digraph amcode_1{
        compound=true;
        rankdir=BT;
        ranksep=1.0;
        node [shape=box, style=filled, fillcolor=lightyellow];
        subgraph cluster0 {
            style=filled;
            color=azure2;
            label="Decorators";
            labelloc="b";
            labeljust="r";
            
            "State control"
            "Unit conversions for incompatible unit systems"
        }
        subgraph cluster1 {
            style=filled;
            color=azure2;
            label="Adaptors";
            labelloc="b";
            labeljust="r";
            "Particles or Gridpoints"
            "Parameters"
            "Methods with Units"
        }
        "Legacy Interface"
        "Legacy Interface"->"Particles or Gridpoints"
        "Legacy Interface"->"Parameters"
        "Legacy Interface"->"Methods with Units"
        "Parameters" -> "State control"[lhead=cluster0, ltail=cluster1];
    }



User Script
***********

This layer contains all the scripts written by a researcher for
a specific problem or set of problems. These scripts are written
in *python* and can use all the functionality provided by the two
lower layers in the AMUSE framework. 
