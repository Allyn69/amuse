=============
Introduction
=============


In this document we will describe the high level design of AMUSE. During
the development period of AMUSE this document will be a 
"Work in Progress". It will be updated to state latests idead about
the design and reflect the current implementation. More detailed 
documentation can be found in the reference documentation

AMUSE
-----
AMUSE combines existing astrophysical numerical codes
into a single system. 

Goal
~~~~

To develop a toolbox for performing numerical astrophysical
experiments.  The toolbox provides:

* A standard way of input and output of astrophysical data.
* Support for set-up and management of numerical experiments.
* A unique method to couple a wide variety of physical codes
* A legacy set of standard, proven codes. These codes will be integrated 
  into AMUSE as modules. Each module can be used stand-alone or in
  combination with other modules
* A standard way for adding new modules to AMUSE.
* Examples to show the use of each module and possible couplings 
  between the modules.
* Documentation containing introduction, howto's and reference documents.


Development
~~~~~~~~~~~
AMUSE development is planned to take place in a 2.5 year period. AMUSE 
is developed at the Leiden Observatory. The Leiden Observatory is
a faculty of the Leiden University in the Netherlands. Funding is provided
by NOVA grant number XXX.

.. image:: ../logos/universiteit_leiden_logo.png
   
.. image:: ../logos/strw_logo.png
   :width: 2.5cm

   
.. image:: ../logos/nova_logo.jpg
   :width: 2.5cm


Architecture
------------

Layers
~~~~~~
The AMUSE architecture is based on a layered design. This layerd design
can be described with 3 layers. The highest layer is a python script, written
for a single problem or set of problems. For example, a simulation of the evolution
of a cluster. The next layer contains the AMUSE code. This layer integrates 
the legacy codes and provides unit handling and data input/output. The
lowest layer contains all the existing codes. In this layer the actual
physical models are implemented. Each layer builds upon a lower layer, as
is depicted in the following figure:

.. graphviz::

   digraph layers0 {
      level1 [label = "1. User Script", shape=box, style=filled,fillcolor=lightsalmon3];
      level2 [label = "2. AMUSE Code", shape=box, style=filled,fillcolor=mediumseagreen];
      level3 [label = "3. Legacy Codes", shape=box, style=filled,fillcolor=lightyellow];
      level1 -> level2 -> level3
   }

Each layer has a different function:

1. User Script. This layer contains all the user scripts. The scripts
   are written in ``python`` and use the functionality provided by the AMUSE
   code layer. Each script can be seen as a realisation of the AMUSE 
   framework for one problem (or a set of problems with the same physics).

2. AMUSE Code. This layer interfaces to the legacy codes and provides
   generic functionalities, such as unit handling and data conversion.This
   layer is very generic, it is not specific for one problem or for one
   physical domain. This layer is written in ``python`` with small interfacing
   parts written in ``C++`` or ``Fortran``.
   
3. Legacy Codes. This layer contains the existing codes. These codes
   may be written in ``C++`` or ``Fortran`` or ``python``. The code in
   this layer is generic in respect to problems, but speficic
   for different physical domains.


AMUSE Code
**********
.. graphviz::

    digraph layers_1 {
      compound=true;
      ranksep=.75;
      nodesep=.5;
      
      subgraph cluster0 {
        node [shape=box, style=filled, fillcolor=white];
        style=filled;
        color=mediumseagreen;
        label="Support";
        
        "Input/Output";
        "Units";
       }
       
       subgraph cluster1 {
        node [shape=box, style=filled, fillcolor=white];
        style=filled;
        color=lightyellow;
        label="Legacy";
        
        "Python Interfaces" -> "Legacy Codes";
       }
       
       subgraph cluster2 {
        node [shape=box, style=filled, fillcolor=white];
        style=filled;
        color=lightblue;
        label="Interface";
        
        "Data Model";
        "Integration of Units";
        "Storage"
       }
       
      
     
      "Integration of Units" -> "Units"[lhead=cluster0, ltail=cluster2]; 
      "Data Model" -> "Python Interfaces"[lhead=cluster1, ltail=cluster2]; 
    }
   
   

.. graphviz::

   digraph layers2 {
      "Interface" [shape=box, style=filled,fillcolor=lightblue];
      "Support" [shape=box, style=filled,fillcolor=mediumseagreen];
      "Legacy"[shape=box, style=filled,fillcolor=lightyellow];
      "User Script" [shape=box, style=filled,fillcolor=lightsalmon3];
      "User Script" -> "Interface"
      "User Script" -> "Legacy"
      "User Script" -> "Support"
   }


Legacy
******

.. graphviz::

   digraph layers4 {
        node [shape=box, style=filled, fillcolor=lightyellow];
        "Python Interfaces" -> "Legacy Codes";
        "Legacy Codes" -> "Gravitational Dynamics";
        "Legacy Codes" -> "Stellar Evolution";
        "Legacy Codes" -> "Hydro Dynamics";
        "Legacy Codes" -> "Radiative Transfer";
    }

Blocks
~~~~~~


Implementation Languages
~~~~~~~~~~~~~~~~~~~~~~~~

.. graphviz::

   digraph layers0 {
      level1 [label = "1. User Script - python ", shape=box, style=filled,fillcolor=lightsalmon3];
      level2 [label = "2. AMUSE Code - python and parts C++ / Fortran", shape=box, style=filled,fillcolor=mediumseagreen];
      level3 [label = "3. Legacy Codes - C++ / Fortran / python", shape=box, style=filled,fillcolor=lightyellow];
      level1 -> level2 -> level3
   }




Algorithm levels
~~~~~~~~~~~~~~~~

A multipurpose framework like AMUSE can provide astrophysical
algorithms on different levels. These levels can range from very low
level building blocks like an integrator or force calculator to higher
level codes that only thake input and provide output. In AMUSE all 
physical modules are self contained, high level building blocks. Every 
module can be seen as a self contained set of functions to evolve a 
physical model. Every module will provide IO and control functions. One 
cannot combine the force calculation functions of one module with the 
integrator of another.

