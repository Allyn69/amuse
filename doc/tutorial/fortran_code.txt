===========================
Integrate a Fortran 90 code
===========================

In this tutorial we will create an AMUSE interface to 
a fortran 90 code. We will first define the
legacy interface, then implement the code and
finally build an object oriented interface on top of the legacy interface.


The legacy code interface supports methods that tranfer values
to and from the code. The values do not have any units and
no error handling is provided by the interface. We can error handling, unit handling
and more functions to the legacy interface by defining a CodeInterface (this is the 
objected oriented interface).

.. graphviz::

   digraph layers4 {
      fontsize=10.0;
        rankdir="LR";
        node [fontsize=10.0, shape=box, style=filled, fillcolor=lightyellow];
        
        "Legacy Code" -> "Legacy Interface" -> "Object Oriented Interface" -> "Script";
    }


The legacy code in this tutorial will be a very simple and naive
implementation to find 3 nearest neighbors of a particle.

Two paths
---------
When defining the interface will walk 2 paths:

1. Management of particles or grids in AMUSE (python)
2. Management of particles or grids in the code (C or Fortran)

The first path makes sense for legacy codes that perform a
transformation on the particles, or analyse the particles state
or do not store any internal state between function calls (all data is external).
For every function of the code, data of every particle is send to the code. If we 
expect multiple calls the code would incur a high communication overhead and we are better 
of choosing path 2.

The second path makes sense for codes that already have management of a 
particles (or grid) or were we want to call multiple functions of the code
and need to send the complete model to code for every function call. The
code is first given the data, then calls are made to the code to evolve
it's model or perform reduction steps on the data, finally the updated data is 
retrieved from the code. 

Procedure
---------

The suggested procedure for creating a new interface is
as follows:

0. **Legacy Interface.** Start with creating the legacy 
   interface. Define functions on the interface to input and
   output relevant data.
   The CodeInterface code depends on the legacy interface code.   
1. **Make a Class.** Create a subclass of the CodeInterface class
2. **Define methods.** In the legacy interface we have defined functions
   with parameters. In the code interface we need to define the
   units of the parameters and if a parameter or return value
   is used as an errorcode.
3. **Define properties.** Some functions in the legacy interface can
   be better described as a property of the code. These are read only 
   variables, like the current model time.
4. **Define parameters.** Some functions in the legacy interface provide
   access to parameters of the code. Units and default values
   need to be defined for the parameters in this step
5. **Define sets or grids.** A code usually handles objects or gridpoints with
   attributes. In this step a generic interface is defined for these
   objects so that the interopability between codes increases.

Before we start
---------------

This tutorial asumes you have a working amuse environment. Please ensure
that amuse is setup correctly by running 'nosetests' in the amuse
directory.

Environment variables
~~~~~~~~~~~~~~~~~~~~~
To simplify the work in the coming sections, we first 
define the environment variable 'AMUSEDIR'. This environment variable
must point to the root directory of AMUSE (this is the directory
containing the build.py script).

.. code-block:: bash

    > export AMUSEDIR=<path to the amuse root directory>
    
or in a c shell:

.. code-block:: csh

    > setenv AMUSEDIR <path to the amuse root directory>

After building the code, we want to run and test the code. 
Check if amuse is available in your python path by running the 
following code on the command line.

.. code-block:: bash

    > python -c "import amuse"
    Traceback (most recent call last):
    File "<string>", line 1, in <module>
    ImportError: No module named amuse
    
If this code ends in a "ImportError" as shown in the example, the
PYTHONPATH environment variable must be extended with the AMUSEDIR. We can do
so by using one of the following commands.

.. code-block:: bash

    > export PYTHONPATH=${PYTHONPATH}:${AMUSEDIR}/src
    
or in a c shell:

.. code-block:: csh

    > setenv AMUSEDIR ${PYTHONPATH}:${AMUSEDIR}/src
    
    
The name of our project
~~~~~~~~~~~~~~~~~~~~~~~
We will be writing a code to find the nearest neighbors of a particle, 
so let's call our project 'NearestNeighbor'.

Creating the initial directory structure
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
First we need to create a directory for our project and put
some files in it to help build the code. This is described in
the *"Create an Interface to a Legacy Code"* tutorial. The fastest
method to setup the directory is by using the build.py script.

.. code-block:: bash

    > $AMUSEDIR/build.py --type=f90 --mode=dir NearestNeighbor

The script will generate a directory with all the files needed
to start our project. It has also generates a very small legacy
code with only one function ```echo_int```. We can build
and test our new module::

    > cd nearestneighbor/
    > make all
    > $AMUSEDIR/amuse.sh -c 'from interface import NearestNeighbor; print NearestNeighbor().echo_int(10)' 
    OrderedDictionary({'int_out':10, '__result':0})
    > nosetests -v
    .
    ----------------------------------------------------------------------
    Ran 1 test in 0.556s

    OK
    
    
.. note::

    The build.py script can be used to generate a range of files. To
    see what this file can do you can run the script with a --help
    parameter, like so::

        > $AMUSEDIR/build.py --help

The Legacy Code
---------------
Normally the legacy code already exists and our task is limited to
defining and implementing an interface so that AMUSE scripts can
access the code. For this tutorial we will implement our legacy code.

When a legacy code is integrated all interface code is put in 
one directory and all the legacy code is put in a **src** directory
placed under this directory. The build.py script created a 
**src** directory for us, and we will put the nearest neighbor algorithm
in this directory.

Go to the **src** directory and create a **code.f90** file, open this
file in your favorite editor and copy and paste this code into it:
    
.. literalinclude:: nearestneighbor/code.f90
    :language: fortran
    

.. note::

    This algorithm is un-optimized and has N*N order. It is not meant
    as very efficient code but as a readable example.

Before we can continue we also need to alter the **Makefile** in the
**src** directory, so that our **code.cc** file is included in the
build. To do so, open an editor on the Makefile and change 
the line::

    CODEOBJS = test.o

to::

    CODEOBJS = test.o code.o
    

Test if the code builds. As we have not coupled our algorithm to the 
interface we (we have not even defined an interface) we do not have any new
functionality. In the legacy interface directory (not the **src** directory) do:

.. code-block:: bash

    > make all
    > nosetests
    .
    ----------------------------------------------------------------------
    Ran 1 test in 0.427s

    OK


Path 1
------

Defining the legacy interface
-----------------------------
We will first define a legacy interface to be able to call the 
**find_nearest_neighbors** function. AMUSE can interact with
2 classes of functions:

1. A function with all scalar input and output variables. All variables
   are simple, non-composite variables (like INTEGER or DOUBLE PRECISION).
   For example:
   
   .. code-block:: fortran
    
        FUNCTION example1(input, output)
            IMPLICIT NONE
            INTEGER example1
            DOUBLE PRECISION input, output
            output = input
            example1 = 0
        END FUNCTION
        
2. A function with all vector (or list) input and output variables and
   a length variable. The return value is a scalar value.



Path 2
------

Defining the legacy interface
-----------------------------
We define our code interface so that a user can add, update and 
delete particles, start the nearest neighbors finding
algorithm and retrieve the ids of the nearest neighbors.

To define the interface, open interface.py with your favorite
editor and replace the contents of this file with:

.. literalinclude:: nearestneighbor/nn1.py

We can generate a stub from the interface code with::

    > $AMUSEDIR/build.py --type=f90 --mode=stub interface.py NearestNeighborInterface -o interface.f90

The generated **interface.f90** replaces the original file generated in
the previous section.

The code still builds, but does not have any functionality yet::

    > make clean
    > make all
    > $AMUSEDIR/amuse.sh -c 'from interface import NearestNeighbor; print NearestNeighbor().find_nearest_neighbors()' 
    0
    
.. note::
    
    Compiling the interface code will result in a lot of warnings about
    unused dummy arguments. These warnings can be savely ignored for now.
    
The tests are broken (the echo_int function has been removed):

.. code-block:: bash

    > nosetests
    E
    ======================================================================
    ERROR: test1 (nearestneighbor.test_nearestneighbor.NearestNeighborInterfaceTests)
    ----------------------------------------------------------------------
    Traceback (most recent call last):
      File "../src/amuse/test/amusetest.py", line 146, in run
        testMethod()
      File "nearestneighbor/test_nearestneighbor.py", line 11, in test1
        result,error = instance.echo_int(12)
    AttributeError: 'NearestNeighborInterface' object has no attribute 'echo_int'

    ----------------------------------------------------------------------
    Ran 1 test in 0.315s

    FAILED (errors=1)

Let's create a working test by calling the new_particle method, open an editor
on the test_nearestneighbor.py file and replace the test1 method with:

.. code-block:: python

    def test1(self):
        instance = NearestNeighborInterface()
        result,error = instance.new_particle(1.0, 1.0, 2.0)
        self.assertEquals(error, 0)
        self.assertEquals(result, 1)
        instance.stop()

As this is python code we do not need to rebuild the code, instead
we can run the tests right after saving the code. Unfortunately, when
we run the test, it still fails.

.. code-block:: bash

    > nosetests
    F
    ======================================================================
    FAIL: test1 (nearestneighbor.test_nearestneighbor.NearestNeighborInterfaceTests)
    ----------------------------------------------------------------------
    Traceback (most recent call last):
      File "/src/amuse/test/amusetest.py", line 146, in run
        testMethod()
      File "/nearestneighbor/test_nearestneighbor.py", line 13, in test1
        self.assertEquals(result, 1)
      File "/src/amuse/test/amusetest.py", line 62, in failUnlessEqual
        self._raise_exceptions_if_any(failures, first, second, '{0} != {1}', msg)
      File "/src/amuse/test/amusetest.py", line 49, in _raise_exceptions_if_any
        raise self.failureException(msg or err_fmt_string.format(first, second, *args))
    AssertionError: 0 != 1
    -------------------- >> begin captured logging << --------------------
    legacy: INFO: start call 'NearestNeighborInterface.new_particle'
    legacy: INFO: end call 'NearestNeighborInterface.new_particle'
    --------------------- >> end captured logging << ---------------------

    ----------------------------------------------------------------------
    Ran 1 test in 0.319s

When you look closely at the output of the test you see that the result from the
method is 0 and not the excpeted 1. We need to edit the fortan code to make this 
test work. Open an editor on interface.f90 and go to the *new_particle* function.

.. code-block:: fortran

    FUNCTION new_particle(index_of_the_particle, x, y, z)
      INTEGER :: index_of_the_particle
      DOUBLE PRECISION :: x, y, z
      index_of_the_particle = 1
      new_particle=0
    END FUNCTION

.. note ::
    
    In AMUSE all interface functions return an errorcode. Any other return
    values must be passed through the arguments of the functions.


We need to rebuild the code, and after building run the tests.


.. code-block:: bash

    > make all
    > nosetests
    .
    ----------------------------------------------------------------------
    Ran 1 test in 0.427s

    OK

The are tests work again! Only, we do not have any real working legacy code.
Filling the stubs
-----------------
The implementation of the algorithm does not match the interface
we defined and created. We need to write some glue code to
connect the code with the interface. To do so we fill in the
stubs generated earlier.

Open the **interface.cc** file in your favorite editor and
change its contents to:

.. literalinclude:: nearestneighbor/interface1.cc
    :language: c++

Test if the code builds and try it out. In the legacy interface
directory do::
    
    > make clean
    > make all
    
We can now start playing with the interface, to start an interactive
python session do::

    > $AMUSEDIR/amuse.sh
    
.. note::

    If you have IPython installed you can also run an interactive
    IPython session like so::
        
        > $AMUSEDIR/iamuse.sh
        
In the python session we can load our code and do some testing:

.. code-block:: python

    >>> from interface import NearestNeighbor
    >>> nn = NearestNeighbor()
    >>> value, error = nn.get_number_of_particles()
    >>> print "number of particles:", value
    number of particles: 0
    >>> all_ids = []
    >>> id, error = nn.new_particle(0.0, 0.0, 0.0)
    >>> print "id of first particle:", id
    id of first particle: 0
    >>> all_ids.append(id)
    >>> for i in range(1,6):
    ...    id, error = nn.new_particle(i*i, 0, 0)
    ...    all_ids.append(id)
    ...
    >>> value, error = nn.get_number_of_particles()
    >>> print "number of particles:", value
    number of particles: 6
    >>> nn.find_nearest_neighbors()
    0
    >>> for i in all_ids:
    ...    print "particle with id", i
    ...    index, distance, error = nn.get_nearest_neighbor(i)
    ...    print "nearest neigbor", index, "has distance", distance
    ...    index0, index1, index2, error = nn.get_close_neighbors(i)
    ...    print "nearest neigbors are:", index0, index1, index2 
    ...
    particle with id 0
    nearest neigbor 1.0 has distance 1.0
    nearest neigbors are: 1.0 2.0 3.0
    particle with id 1
    nearest neigbor 0.0 has distance 1.0
    nearest neigbors are: 0.0 2.0 3.0
    particle with id 2
    nearest neigbor 1.0 has distance 3.0
    nearest neigbors are: 1.0 0.0 3.0
    particle with id 3
    nearest neigbor 2.0 has distance 5.0
    nearest neigbors are: 2.0 4.0 1.0
    particle with id 4
    nearest neigbor 3.0 has distance 7.0
    nearest neigbors are: 3.0 5.0 2.0
    particle with id 5
    nearest neigbor 4.0 has distance 9.0
    nearest neigbors are: 4.0 3.0 2.0
    
We now have done everything in Step 0 *Legacy Interface*. We have
a legacy code and can access it in our python script. But, our
interface is not very friendly to work with. We have to think about
errorcodes and we have not information about units. To make our
interface easier to works with we start defining methods, properties
and parameters.

Defining methods
----------------
The object oriented interface is also defined in the **interface.py**.
So, we continue by opening an editor on this file. We will be 
writing methods for the **NearestNeighbor** class, in your editor
seek this code (at the end of the file)::

    class NearestNeighbor(CodeInterface):

        def __init__(self):
            CodeInterface.__init__(self,  NearestNeighborInterface())
            
We will start by defining methods, we will do this by implementing
the **define_methods** function, like so::

     class NearestNeighbor(CodeInterface):

        def __init__(self):
            CodeInterface.__init__(self,  NearestNeighborInterface())
            
        
        def define_methods(self, builder):
            
            builder.add_method(
                "new_particle", 
                (units.m, units.m, units.m,),
                (builder.INDEX, builder.ERROR_CODE)
            )
            
            builder.add_method(
                "delete_particle", 
                (builder.INDEX,),
                (builder.ERROR_CODE)
            )
            
            builder.add_method(
                "get_state", 
                (builder.INDEX,),
                (units.m, units.m, units.m, builder.ERROR_CODE),
                public_name = "get_position"
            )
            
            builder.add_method(
                "set_state", 
                (builder.INDEX, units.m, units.m, units.m,),
                (builder.ERROR_CODE),
                public_name = "set_position"
            )
            
            builder.add_method(
                "find_nearest_neighbors", 
                (),
                (builder.ERROR_CODE),
            )
            
            builder.add_method(
                "get_close_neighbors", 
                (builder.INDEX,),
                (builder.INDEX, builder.INDEX, builder.INDEX, builder.ERROR_CODE),
            )
            
            builder.add_method(
                "get_nearest_neighbor", 
                (builder.INDEX,),
                (builder.INDEX, units.m, builder.ERROR_CODE),
            )
            
            builder.add_method(
                "get_number_of_particles", 
                (),
                (builder.NO_UNIT, builder.ERROR_CODE),
            )
        
With this code, we define the methods and specify how to interpret the
arguments and return values. We get a special object (the **builder**
object) that provides us with the **add_method** function to be able
to this. The definition of the **add_method** function is as follows::
    
    add_method(
        name of the original function in the legacy interface,
        list of arguments (unit or type),
        list of return values,
        public_name = name for the user of the class (optional)
    )
    
For every argument or return value we can specify if it has a unit or
if it is special. The special arguments are:

================== ===================================
definition         description
================== ===================================
builder.ERROR_CODE the value is interpreted as an errorcode,
                   zero means no error for all other values and
                   Exception will be raise, only valid for one return value.
builder.NO_UNIT    the value has not unit (for example for the
                   number of items in a list)
builder.INDEX      the value is interpreted as an index for
                   object identifiers
================== ===================================

Test if the code builds and try it out. In the legacy interface
directory do::
    
    > make clean
    > make all

Let's start an interactive python session and play with the code::

    >>> from interface import NearestNeighbor
    >>> from amuse.support.units import units
    >>> nn = NearestNeighbor()
    >>> print "number of particles:", nn.get_number_of_particles()
    number of particles: 0
    >>> all_ids = []
    >>> id = nn.new_particle(0.0 | units.km , 0.0 | units.km , 0.0 | units.km)
    >>> print "id of the particle:", id
    id of the particle: 0
    >>> all_ids.append(id)
    >>> for i in range(1,6):
    ...     id = nn.new_particle(i*i | units.km, 0 | units.km, 0 | units.km)
    ...     all_ids.append(id)
    ... 
    >>> print "number of particles:", nn.get_number_of_particles()
    number of particles: 6
    >>> nn.find_nearest_neighbors()
    >>> for i in all_ids:
    ...     print "particle with id", i
    ...     index, distance = nn.get_nearest_neighbor(i)
    ...     print "nearest neigbor", index, "has distance", distance
    ...     index0, index1, index2 = nn.get_close_neighbors(i)
    ...     print "nearest neigbors are:", index0, index1, index2
    ... 
    particle with id 0
    nearest neigbor 1.0 has distance 1000.0 m
    nearest neigbors are: 1.0 2.0 3.0
    particle with id 1
    nearest neigbor 0.0 has distance 1000.0 m
    nearest neigbors are: 0.0 2.0 3.0
    particle with id 2
    nearest neigbor 1.0 has distance 3000.0 m
    nearest neigbors are: 1.0 0.0 3.0
    particle with id 3
    nearest neigbor 2.0 has distance 5000.0 m
    nearest neigbors are: 2.0 4.0 1.0
    particle with id 4
    nearest neigbor 3.0 has distance 7000.0 m
    nearest neigbors are: 3.0 5.0 2.0
    particle with id 5
    nearest neigbor 4.0 has distance 9000.0 m
    nearest neigbors are: 4.0 3.0 2.0

As you can see our script is now a little simpler and we support units.
We do not have to think about the errorcodes in this script, AMUSE will
interpret the errorcodes and raise the right exceptions if needed. The 
units are also automatically converted to the right units for the 
code. But the script is still not very easy and we have to manage
all the ids we get from the code. To make our code even easier to
handle we will continue by defining a **set**.

.. note::

    We skip defining parameters and properties, we will come back to 
    this later in this tutorial.

Defining a set
--------------
We have made our interface a little easier but we still have to
do a some management work in our script. We would like to work
with objects and adding or removing these objects from the code.
AMUSE supports this by defining **sets**. Each set is capable of
storing specific attributes of the objects in the set. Our code
is capable of storing the x, y and z position of an object. An object
in AMUSE is called a *Particle* and the sets that contain these
particles are called *ParticleSets* or shorter *Particles*.

We define our particle set by implementing a **define_particle_sets** 
function on our **NearestNeighbor** class like so::

    class NearestNeighbor(CodeInterface):

        def __init__(self):
            CodeInterface.__init__(self,  NearestNeighborInterface())
            
        
        def define_methods(self, builder):
            ...
            
        def define_particle_sets(self, builder):
            builder.define_set('particles', 'index_of_the_particle')
            builder.set_new('particles', 'new_particle')
            builder.set_delete('particles', 'delete_particle')
            builder.add_setter('particles', 'set_position')
            builder.add_getter('particles', 'get_position')
            builder.add_getter('particles', 'get_close_neighbors', names=('neighbor1', 'neighbor2', 'neighbor3') )


That's all, we now have defined a set called **particles**. Again, we 
get a builder object to use in defining our set. All methods have
the name of the set as their first argument, this name can be any
name you want, but in AMUSE most codes provide a set called 
**particles**. For the **add_setter**, **add_getter**, **set_new** 
and **set_delete** functions, the second argument is the name of
the method we defined in the previous step. Finally you can set
the name of the attribute in the particles set with the **names**
argument. This is optional for legacy functions, if not given the names 
of the attributes will be derived from the names of the arguments in
the orginal calls. For example, the **get_position** call we specified
earlier has parameter name **x**, **y** and **z**, these names are 
also used in the particles set.

Test if the code builds and try it out. In the legacy interface
directory do::
    
    > make clean
    > make all

We start an interactive python session and play with the code again:

    >>> from interface import NearestNeighbor
    >>> from amuse.support.units import units
    >>> from amuse.support.data import core
    >>> nn = NearestNeighbor()
    >>> print "number of particles:", len(nn.particles)
    number of particles: 0
    >>> particle = core.Particle()
    >>> particle.position = (0.0, 0.0, 0.0 ) | units.km
    >>> nn.particles.add_particle(particle)
    >>> for i in range(1,6):
    ...     particle = core.Particle()
    ...     particle.position = (i*i, 0.0, 0.0 ) | units.km
    ...     nn.particles.add_particle(particle)
    ... 
    >>> print "number of particles:", len(nn.particles)
    number of particles: 6
    >>> nn.find_nearest_neighbors()
    >>> for particle in nn.particles:
    ...     print particle
    ...     print particle.x, particle.neighbor.x
    Particle(...)
    0.0 m 1000.0 m
    
The support for a particle set means we can now also interact
with other parts of AMUSE. Let's make a plummer model and 
find the nearest neighbors in this model.

First make a file with the following contents, let's call this file
**plummer1.py**:

.. literalinclude:: nearestneighbor/plummer1.py
    :language: python

We can run this file with python::

    $AMUSEDIR/amuse.sh plummer1.py
    
It will create an **output.txt** file and we can show this file
with gnuplot.

.. code-block:: gnuplot

    gnuplot> splot 'output.txt' using 1:2:3:4:5:6 with vectors nohead, 'output.txt' using 1:2:3
    gnuplot> #we can zoom into the center
    gnuplot> set xr[-0.5:0.5]
    gnuplot> set yr[-0.5:0.5]
    gnuplot> set zr[-0.5:0.5]
    gnuplot> splot 'output.txt' using 1:2:3:4:5:6 with vectors nohead, 'output.txt' using 1:2:3
    

.. image:: nearestneighbor/plummer1.png

You can extend this example by showing the second or third nearest neighbors, or
simply increase the number of particles in the plummer model.

    

    
    








