===========================================================
Create an Object Oriented interface on top of a Legacy Code
===========================================================

In this tutorial we will add an object oriented interface 
to a legacy code. We will first define the legacy interface,
then implement the code and finally build an object
oriented interface on top of the code. The legacy code
will be a very simple and naive implementation to find
3 nearest neighbors of a particle.

The legacy code interface supports methods that tranfer values
to and from the code. The values do not have any units and
no apart from error codes, and no error handling is 
provided by the interface. We can add these and more functions
to the legacy interface by defining a CodeInterface.

The suggested procedure for creating the new interface is
as follow:

0. **Legacy Interface.** Start with creating the legacy 
   interface (see previous tutorial).
   The CodeInterface code depends on the legacy interface code.   
1. **Make a Class.** Create a subclass of the CodeInterface class
2. **Define methods.** In the legacy interface we have defined functions
   with parameters. In the code interface we need to define the
   units of the parameters and if a parameter or return value
   is used as an errorcode.
3. **Define properties.** Some functions in the legacy interface can
   be better described as a property of the code.
4. **Define parameters.** Some functions in the legacy interface provide
   access to parameters of the code. Units and default values
   can be defined for the parameters in this step
5. **Define sets.** A code usually handles objects or gridpoints with
   attributes. In this step a generic interface is defined for these
   objects so that the interopability between codes increases.
6. **Define a Unit Converter.** This step is only needed for codes
   that have units which are incompatible with SI units. For example
   if a code uses nbody units, a converter is needed to convert
   between nbody and si units.


Environment variables
---------------------
This tutorial asumes you have a working amuse environment. Please ensure
that amuse is setup correctly by running 'nosetests' in the amuse
directory.

To simplify the work in the coming sections, we first 
define the environment variable 'AMUSEDIR'. This environment variable
must point to the root directory of AMUSE (this is the directory
containing the build.py script).

.. code-block:: bash

    > export AMUSEDIR=<path to the amuse root directory>
    
or in a c shell:

.. code-block:: csh

    > setenv AMUSEDIR <path to the amuse root directory>
    
The name of our project
-----------------------
We will be writing a code to find the nearest neighbors of a particle, 
so let's call our project 'NearestNeighbor'.

Setting up the project
----------------------
First we need to create a directory for our project and put
some files in it to help build the code. This is described in
the *"Create an Interface to a Legacy Code"* tutorial. The fastest
method to setup the directory is by using the build.py script.

.. code-block:: bash

    > $AMUSEDIR/build.py --mode=dir NearestNeighbor

The script has generated a directory with all the files needed
to start our project. It has also generated a very small legacy
code with only one function ```echo_int```. We can build
and test our new module::

    > cd nearestneighbor/
    > make all
    > $AMUSEDIR/amuse.sh -c 'from interface import NearestNeighbor; print NearestNeighbor().echo_int(10)' 
    OrderedDictionary({'int_out':10, '__result':0})
    
.. note::

    The build.py script can be used to generate a range of files. To
    see what this file can do you can run the script with a --help
    parameter, like so::

        > $AMUSEDIR/build.py --help

Defining the legacy interface
-----------------------------
We define our code interface so that a user can add, update and 
delete particles, start the nearest neighbors finding
algorithm and retrieve the ids of the nearest neighbors.

To define the interface, open interface.py with your favorite
editor and replace the contents of this file with:

.. literalinclude:: nearestneighbor/nn1.py

We can generate a stub from the interface code with::

    > $AMUSEDIR/build.py --type=c --mode=stub interface.py NearestNeighborInterface -o interface.cc

The generated **interface.cc** replaces the original file generated in
the previous section.

The code still builds, but does not have any functionality yet::

    > make clean
    > make all
    > $AMUSEDIR/amuse.sh -c 'from interface import NearestNeighbor; print NearestNeighbor().find_nearest_neighbors()' 
    0
    
Writing the legacy code
-----------------------
Normally the legacy code already exists and our task is limited to
defining and implementing an interface so that AMUSE scripts can
access the code. For this tutorial we will implement our legacy code.

When a legacy code is integrated all interface code is put in 
one directory and all the legacy code is put in a **src** directory
placed under this directory. Our example legacy code also contains 
a **src** directory and we will put the nearest neighbor algorithm
in this directory.

Go to the **src** directory and create a **code.cc** file, open this
file in your favorite editor and:
    
.. literalinclude:: nearestneighbor/code.cc
    :language: c++
    

You also need to create a header file the **src** directory. We will
call this file **code.h** and sets its content as:

.. literalinclude:: nearestneighbor/code.h
    :language: c++

.. note::

    This algorithm is un-optimized and has N*N order. It is not meant
    as very efficient code but as a readable example.

Before we can continue we also need to alter the **Makefile** in the
**src** directory, so that our **code.cc** file is included in the
build. To do so, open an editor on the Makefile and change 
the line::

    CODEOBJS = test.o

to::

    CODEOBJS = code.o
    

Test if the code builds. As we have not coupled our algorithm to the 
interface we do not have any new functionality. In the legacy interface
directory (not the **src** directory) do::

    > make all
    > $AMUSEDIR/amuse.sh -c 'from interface import NearestNeighbor; print NearestNeighbor().find_nearest_neighbors()' 
    0

Filling the stubs
-----------------
The implementation of the algorithm does not match the interface
we defined and created. We need to write some glue code to
connect the code with the interface. To do so we fill in the
stubs generated earlier.

Open the **interface.cc** file in your favorite editor and
change its contents to:

.. literalinclude:: nearestneighbor/interface1.cc
    :language: c++

Test if the code builds and try it out. In the legacy interface
directory do::
    
    > make clean
    > make all
    
We can now start playing with the interface, to start an interactive
python session do::

    > $AMUSEDIR/amuse.sh
    
.. note::

    If you have IPython installed you can also run an interactive
    IPython session like so::
        
        > $AMUSEDIR/iamuse.sh
        
In the python session we can load our code and do some testing:

.. code-block:: python

    >>> from interface import NearestNeighbor
    >>> nn = NearestNeighbor()
    >>> value, error = nn.get_number_of_particles()
    >>> print "number of particles:", value
    number of particles: 0
    >>> all_ids = []
    >>> id, error = nn.new_particle(0.0, 0.0, 0.0)
    >>> print "id of first particle:", id
    id of first particle: 0
    >>> all_ids.append(id)
    >>> for i in range(1,6):
    ...    id, error = nn.new_particle(i*i, 0, 0)
    ...    all_ids.append(id)
    ...
    >>> value, error = nn.get_number_of_particles()
    >>> print "number of particles:", value
    number of particles: 6
    >>> nn.find_nearest_neighbors()
    0
    >>> for i in all_ids:
    ...    print "particle with id", i
    ...    index, distance, error = nn.get_nearest_neighbor(i)
    ...    print "nearest neigbor", index, "has distance", distance
    ...    index0, index1, index2, error = nn.get_close_neighbors(i)
    ...    print "nearest neigbors are:", index0, index1, index2 
    ...
    particle with id 0
    nearest neigbor 1.0 has distance 1.0
    nearest neigbors are: 1.0 2.0 3.0
    particle with id 1
    nearest neigbor 0.0 has distance 1.0
    nearest neigbors are: 0.0 2.0 3.0
    particle with id 2
    nearest neigbor 1.0 has distance 3.0
    nearest neigbors are: 1.0 0.0 3.0
    particle with id 3
    nearest neigbor 2.0 has distance 5.0
    nearest neigbors are: 2.0 4.0 1.0
    particle with id 4
    nearest neigbor 3.0 has distance 7.0
    nearest neigbors are: 3.0 5.0 2.0
    particle with id 5
    nearest neigbor 4.0 has distance 9.0
    nearest neigbors are: 4.0 3.0 2.0
    
We now have done everything in Step 0 *Legacy Interface*. We have
a legacy code and can access it in our python script. But, our
interface is not very friendly to work with. We have to think about
errorcodes and we have not information about units. To make our
interface easier to works with we start defining methods, properties
and parameters.

Defining methods
----------------
The object oriented interface is also defined in the **interface.py**.
So, we continue by opening an editor on this file. We will be 
writing methods for the **NearestNeighbor** class, in your editor
seek this code (at the end of the file)::

    class NearestNeighbor(CodeInterface):

        def __init__(self):
            CodeInterface.__init__(self,  NearestNeighborInterface())
            
We will start by defining methods, we will do this by implementing
the **define_methods** function, like so::

     class NearestNeighbor(CodeInterface):

        def __init__(self):
            CodeInterface.__init__(self,  NearestNeighborInterface())
            
        
        def define_methods(self, builder):
            
            builder.add_method(
                "new_particle", 
                (units.m, units.m, units.m,),
                (builder.INDEX, builder.ERROR_CODE)
            )
            
            builder.add_method(
                "delete_particle", 
                (builder.INDEX,),
                (builder.ERROR_CODE)
            )
            
            builder.add_method(
                "get_state", 
                (builder.INDEX,),
                (units.m, units.m, units.m, builder.ERROR_CODE),
                public_name = "get_position"
            )
            
            builder.add_method(
                "set_state", 
                (builder.INDEX, units.m, units.m, units.m,),
                (builder.ERROR_CODE),
                public_name = "set_position"
            )
            
            builder.add_method(
                "find_nearest_neighbors", 
                (),
                (builder.ERROR_CODE),
            )
            
            builder.add_method(
                "get_close_neighbors", 
                (builder.INDEX,),
                (builder.INDEX, builder.INDEX, builder.INDEX, builder.ERROR_CODE),
            )
            
            builder.add_method(
                "get_nearest_neighbor", 
                (builder.INDEX,),
                (builder.INDEX, units.m, builder.ERROR_CODE),
            )
            
            builder.add_method(
                "get_number_of_particles", 
                (),
                (builder.NO_UNIT, builder.ERROR_CODE),
            )
        
With this code, we define the methods and specify how to interpret the
arguments and return values. We get a special object (the **builder**
object) that provides us with the **add_method** function to be able
to this. The definition of the **add_method** function is as follows::
    
    add_method(
        name of the original function in the legacy interface,
        list of arguments (unit or type),
        list of return values,
        public_name = name for the user of the class (optional)
    )
    
For every argument or return value we can specify if it has a unit or
if it is special. The special arguments are:

================== ===================================
definition         description
================== ===================================
builder.ERROR_CODE the value is interpreted as an errorcode,
                   zero means no error for all other values and
                   Exception will be raise, only valid for one return value.
builder.NO_UNIT    the value has not unit (for example for the
                   number of items in a list)
builder.INDEX      the value is interpreted as an index for
                   object identifiers
================== ===================================

Test if the code builds and try it out. In the legacy interface
directory do::
    
    > make clean
    > make all

Let's start an interactive python session and play with the code::

    >>> from interface import NearestNeighbor
    >>> from amuse.support.units import units
    >>> nn = NearestNeighbor()
    >>> print "number of particles:", nn.get_number_of_particles()
    number of particles: 0
    >>> all_ids = []
    >>> id = nn.new_particle(0.0 | units.km , 0.0 | units.km , 0.0 | units.km)
    >>> print "id of the particle:", id
    id of the particle: 0
    >>> all_ids.append(id)
    >>> for i in range(1,6):
    ...     id = nn.new_particle(i*i | units.km, 0 | units.km, 0 | units.km)
    ...     all_ids.append(id)
    ... 
    >>> print "number of particles:", nn.get_number_of_particles()
    number of particles: 6
    >>> nn.find_nearest_neighbors()
    >>> for i in all_ids:
    ...     print "particle with id", i
    ...     index, distance = nn.get_nearest_neighbor(i)
    ...     print "nearest neigbor", index, "has distance", distance
    ...     index0, index1, index2 = nn.get_close_neighbors(i)
    ...     print "nearest neigbors are:", index0, index1, index2
    ... 
    particle with id 0
    nearest neigbor 1.0 has distance 1000.0 m
    nearest neigbors are: 1.0 2.0 3.0
    particle with id 1
    nearest neigbor 0.0 has distance 1000.0 m
    nearest neigbors are: 0.0 2.0 3.0
    particle with id 2
    nearest neigbor 1.0 has distance 3000.0 m
    nearest neigbors are: 1.0 0.0 3.0
    particle with id 3
    nearest neigbor 2.0 has distance 5000.0 m
    nearest neigbors are: 2.0 4.0 1.0
    particle with id 4
    nearest neigbor 3.0 has distance 7000.0 m
    nearest neigbors are: 3.0 5.0 2.0
    particle with id 5
    nearest neigbor 4.0 has distance 9000.0 m
    nearest neigbors are: 4.0 3.0 2.0

As you can see our script is now a little simpler and we support units.
We do not have to think about the errorcodes in this script, AMUSE will
interpret the errorcodes and raise the right exceptions if needed. The 
units are also automatically converted to the right units for the 
code. But the script is still not very easy and we have to manage
all the ids we get from the code. To make our code even easier to
handle we will continue by defining a **set**.

.. note::

    We skip defining parameters and properties, we will come back to 
    this later in this tutorial.

Defining a set
--------------
We have made our interface a little easier but we still have to
do a some management work in our script. We would like to work
with objects and adding or removing these objects from the code.
AMUSE supports this by defining **sets**. Each set is capable of
storing specific attributes of the objects in the set. Our code
is capable of storing the x, y and z position of an object. An object
in AMUSE is called a *Particle* and the sets that contain these
particles are called *ParticleSets* or shorter *Particles*.

We define our particle set by implementing a **define_particle_sets** 
function on our **NearestNeighbor** class like so::

    class NearestNeighbor(CodeInterface):

        def __init__(self):
            CodeInterface.__init__(self,  NearestNeighborInterface())
            
        
        def define_methods(self, builder):
            ...
            
        def define_particle_sets(self, builder):
            builder.define_set('particles', 'index_of_the_particle')
            builder.set_new('particles', 'new_particle')
            builder.set_delete('particles', 'delete_particle')
            builder.add_setter('particles', 'set_position')
            builder.add_getter('particles', 'get_position')
            builder.add_getter('particles', 'get_close_neighbors', names=('neighbor1', 'neighbor2', 'neighbor3') )


That's all, we now have defined a set called **particles**. Again, we 
get a builder object to use in defining our set. All methods have
the name of the set as their first argument, this name can be any
name you want, but in AMUSE most codes provide a set called 
**particles**. For the **add_setter**, **add_getter**, **set_new** 
and **set_delete** functions, the second argument is the name of
the method we defined in the previous step. Finally you can set
the name of the attribute in the particles set with the **names**
argument. This is optional for legacy functions, if not given the names 
of the attributes will be derived from the names of the arguments in
the orginal calls. For example, the **get_position** call we specified
earlier has parameter name **x**, **y** and **z**, these names are 
also used in the particles set.

Test if the code builds and try it out. In the legacy interface
directory do::
    
    > make clean
    > make all

We start an interactive python session and play with the code again:

    >>> from interface import NearestNeighbor
    >>> from amuse.support.units import units
    >>> from amuse.support.data import core
    >>> nn = NearestNeighbor()
    >>> print "number of particles:", len(nn.particles)
    number of particles: 0
    >>> particle = core.Particle()
    >>> particle.position = (0.0, 0.0, 0.0 ) | units.km
    >>> nn.particles.add_particle(particle)
    >>> for i in range(1,6):
    ...     particle = core.Particle()
    ...     particle.position = (i*i, 0.0, 0.0 ) | units.km
    ...     nn.particles.add_particle(particle)
    ... 
    >>> print "number of particles:", len(nn.particles)
    number of particles: 6
    >>> nn.find_nearest_neighbors()
    >>> for particle in nn.particles:
    ...     print particle
    ...     print particle.x, particle.neighbor.x
    Particle(...)
    0.0 m 1000.0 m
    
The support for a particle set means we can now also interact
with other parts of AMUSE. Let's make a plummer model and 
find the nearest neighbors in this model.

First make a file with the following contents, let's call this file
**plummer1.py**:

.. literalinclude:: nearestneighbor/plummer1.py
    :language: python

We can run this file with python::

    $AMUSEDIR/amuse.sh plummer1.py
    
It will create an **output.txt** file and we can show this file
with gnuplot.

.. code-block:: gnuplot

    gnuplot> splot 'output.txt' using 1:2:3:4:5:6 with vectors nohead, 'output.txt' using 1:2:3
    gnuplot> #we can zoom into the center
    gnuplot> set xr[-0.5:0.5]
    gnuplot> set yr[-0.5:0.5]
    gnuplot> set zr[-0.5:0.5]
    gnuplot> splot 'output.txt' using 1:2:3:4:5:6 with vectors nohead, 'output.txt' using 1:2:3
    

.. image:: nearestneighbor/plummer1.png

You can extend this example by showing the second or third nearest neighbors, or
simply increase the number of particles in the plummer model.

    

    
    








